			|—— DUBBO |——服务注册中心：zookeeper
			|		  |——服务调用方式：高性能透明化RPC，提供Dubbo、Hessian、HTTP、RMI、WebService、Thrift、Memcached、Redis协议支持
			|		  |——断路器：集群容错
微服务框架:   |
			|—— SpringCloud |——服务注册中心：eureka
			 		        |——服务调用方式：REST API
			 		  		|——断路器：Hystrix
			 		  		|...

孰优孰劣？Dubbo VS Spring Cloud性能测试大对决！ https://mp.weixin.qq.com/s/omVAEzQTcV5o5AGsSU_u7Q

TPS：每秒事务处理量

ExtensionLoader：拓展加载器，dubbo spi的核心类。
dubbo模仿jdk的spi实现了自己的spi，和jdk spi的初衷一样的是，dubbo的spi也是实现的一种服务发现机制。
在这个基础上，dubbo又增加了对ioc，aop和动态编译compiler的支持。

dubbo内核的组成部分：SPI，AOP，IOC，Compiler。

SPI
    目的：获取一个实现类的对象。
    实现：ExtensionLoader;
    步骤：
        1.getExtensionLoader(Class<T> type); 为接口类型T获取ExtensionLoader对象
        2.getAdaptiveExtension(); 获取 T类型的 含@Adaptive的扩展类 的实例，如果扩展类中的@Adaptive注解在类上，
            则是人工实现的装饰类对象(如AdaptiveExtensionFactory)；如果注解在方法上，则是动态生成的动态代理类对象(如Protocol$Adaptive)。
        3.getExtension(String name); 获取一个实现类的对象

    1)扩展加载器的获取
    ----------------ExtensionLoader.getExtensionLoader(Class<T> type)
    ExtensionLoader.getExtensionLoader(Container.class)
        -->this.type = type;
        -->objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension();
          -->ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension();
            -->this.type = type;
            -->objectFactory = null;

    1.每个ExtensionLoader对象都有type 和 objectFactory
    2.private static final ConcurrentMap<Class<?>, ExtensionLoader<?>> EXTENSION_LOADERS
    其中存储着 全局的 字节码对象 和对应的 扩展加载器

    2)spi adaptive原理
    @Adaptive注解意义：
        @Adaptive注解在类上，代表这是一个人工实现的装饰类，如AdaptiveExtensionFactory
        @Adaptive注解在方法上，则生成一个动态代理类，如Protocol$Adaptive

    ----------------loader.getAdaptiveExtension()
    getAdaptiveExtension()//为cachedAdaptiveInstance赋值
        -->createAdaptiveExtension()//单例模式第一次创建T类型的含@Adaptive扩展类实例
            -->getAdaptiveExtensionClass()//获取T类型含@Adaptive的扩展类的字节码对象
                -->getExtensionClasses()//获取并初始化cachedClasses
                    -->loadExtensionClasses()//从配置文件中加载 扩展类字节码对象 信息缓存到cachedAdaptiveClass, cachedWrapperClasses, cachedNames, cachedActivates中
                        -->loadFile()
                -->createAdaptiveExtensionClass()//自动生成一个Adaptive动态代理类，并编译
                    -->ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension()
                    -->compiler.compile(code, classLoader)
            -->injectExtension()//进入Ioc控制反转模式，实现动态注入

    cachedClasses: 缓存一个map，map以< everyName,clazz>存储 没有@Adaptive，构造器没有type类型参数的 扩展类class对象

    loadFile细节：
        目的：将配置文件META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol中的内容，缓存在如下变量中：
            cachedAdaptiveClass: 缓存含有@Adaptive的class，例如ExtensionFactory的AdaptiveExtensionFactory，而Protocol接口则没有。
            cachedWrapperClasses: 缓存没有@Adaptive的class，并且构造器没有type类型参数，例如Protocol spi中的ProtocolFilterWrapper和ProtocolListenerWrapper。
            cachedNames:除了cachedAdaptiveClass、cachedWrapperClasses中的。
            cachedActivates:cachedNames中含有@Activate注解的。
